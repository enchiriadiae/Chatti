# config_loader.py
from __future__ import annotations

import os
import re
from pathlib import Path

from core.paths import PUBLIC_CONF, SYSTEM, user_conf_file

# -----------------------------------------------
# Write User-Config-File during first Initialization
# -----------------------------------------------

# Keys the user MUST NOT override (central ops only)
_EXCLUDE_FROM_USER_OVERRIDE = {
    "api_selfcheck",
    "api_selfcheck_stream",
    "api_selfcheck_verbose",
    "api_selfcheck_interval_hours",
}

def _is_meaningful_value(v: object) -> bool:
    """Only treat non-empty values as 'set'."""
    if v is None:
        return False
    if isinstance(v, str):
        return bool(v.strip())
    return True  # numbers/bools/etc

def _secure_write_text(path: Path, text: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    if SYSTEM == "Windows":
        path.write_text(text, encoding="utf-8")
    else:
        fd = os.open(str(path), os.O_WRONLY | os.O_CREAT | os.O_TRUNC, 0o600)
        with os.fdopen(fd, "w", encoding="utf-8") as f:
            f.write(text)

_SKELETON_USER_CONF = """# chatti.conf (per-User) – Skeleton
# Diese Datei überschreibt zentrale Defaults NUR für diesen Benutzer.
# Alle Zeilen sind optional; auskommentierte Beispiele zeigen sinnvolle Werte.

# ============ Darstellung ============
#pretty_output = true          # ANSI-Farben, kleine Emojis etc.
#u_colour = cyan               # User-Farbe (ANSI-Name)
#c_colour = green              # Assistant-Farbe
#s_colour = yellow             # Suchmodus-Farbe
#ansi_bold = bold
#ansi_reset = reset

# Labels in der TUI ("Namensschild" für die KI und die/den Anwender/In)
#user_label = User
#assistant_label = Chatti

# --- Boss-Mode (optional) ---
# Wenn leer → Boss-Mode nur per Tastenkombi ein/aus.
# Wenn gesetzt → Boss-Mode nur mit diesem Code wieder beendbar.
# Tipp: Nur simple Zeichenketten, kein echtes Passwort nötig.
# boss_passcode = changeme

# Welcome am Anfang (Um die Begrüßung zu überspringen, die beiden Rauten entfernen)
# show_ascii_art = false
# show_welcome = false

search_limit = 20
search_case_sensitive = false

# ============ Prompt ============
# system_prompt = Du bist hilfsbereit und knapp.
# system_prompt_style = knapp   # knapp | freundlich | technisch | coach | humor
# system_prompt_file = prompts/my_system_prompt.txt   # relativ zur Conf-Datei

# ============ PDFs ============
# pdf_text_only = false         # true = keine Seitenrenderings als Bilder
# pdf_max_pages = 2             # 0 = unbegrenzt (vorsicht bei großen PDFs)

# ============ Modelle ============
# default_model = gpt-4o

# ============ History ============
# history_max = 200             # maximale Einträge in der Ausgabe-Historie
# input_history_max = 200       # vorzuladende Anzahl vergangener Eingaben
# preload_input_history = true
"""

def ensure_user_conf_skeleton(uid: str) -> Path:
    """
    Legt eine per-User-Konfigdatei (Skeleton) an, falls noch nicht vorhanden.
    Gibt den Pfad zurück.
    """
    cfg_path = user_conf_file(uid)
    if not cfg_path.exists():
        _secure_write_text(cfg_path, _SKELETON_USER_CONF)
    return cfg_path

def _quote_if_needed(v: str) -> str:
    s = v.strip()
    return s if (s and s[0] in "'\"" and s[-1] == s[0]) else f'"{s}"'

# --------------------------------------
# Config-Files:
# use chatti.conf as Default, override, if User-specific *confs are found.
# --------------------------------------

def load_config_effective(uid: str | None = None) -> dict[str, str]:
    """
    Merge global chatti.conf with per-user overrides:
    - Start with global config.
    - Overlay only keys that are set to a meaningful value in user config.
    - Block user overrides for maintenance toggles listed above.
    """
    global_conf = load_config(str(PUBLIC_CONF)) or {}
    if uid:
        upath = user_conf_file(uid)
        user_conf = load_config(str(upath)) if upath.exists() else {}
    else:
        user_conf = {}

    merged = dict(global_conf)
    for k, v in (user_conf or {}).items():
        if k in _EXCLUDE_FROM_USER_OVERRIDE:
            continue
        if _is_meaningful_value(v):
            merged[k] = v
    return merged

# --- Make a small, reusable key-val writer that can write to user or global conf ---
def _write_kv_in_file(path: Path, key: str, value: str | None) -> None:
    """
    Fügt eine „key = value“-Zeile in eine .conf-Datei ein oder ersetzt sie.
    Kommentare und andere Einträge in der Datei bleiben unverändert.
    Falls die Datei oder ihre übergeordneten Verzeichnisse noch nicht existieren,
    werden sie automatisch angelegt.
    """

    path = Path(path)
    path.parent.mkdir(parents=True, exist_ok=True)
    if not path.exists():
        path.write_text("# auto-generated by chatti\n", encoding="utf-8")

    lines = path.read_text(encoding="utf-8").splitlines()

    # wie beim Laden normalisieren: lower + Strip + "-" -> "_"
    key_norm = key.strip().lower().replace("-", "_")
    val_str = "" if value is None else str(value)
    new_line = f"{key_norm} = {_quote_if_needed(val_str)}"

    found = False
    for i, line in enumerate(lines):
        raw = line.strip()
        if not raw or raw.startswith(("#", ";")):
            continue
        before = raw.split("#", 1)[0].split(";", 1)[0].strip()
        if "=" in before:
            k, _ = before.split("=", 1)
            if k.strip().lower().replace("-", "_") == key_norm:
                lines[i] = new_line
                found = True
                break

    if not found:
        if lines and lines[-1] != "":
            lines.append("")
        lines.append(new_line)

    path.write_text("\n".join(lines) + "\n", encoding="utf-8")

def write_conf_kv_scoped(key: str, value: str, uid: str | None = None) -> None:
    """
    Write a k=v into the active user's chatti.conf, if uid given/active;
    otherwise to global chatti.conf
    """
    if uid:
        _write_kv_in_file(user_conf_file(uid), key, value)
    else:
        _write_kv_in_file(PUBLIC_CONF, key, value)


# Erlaubt #FFF oder #FFA500 als Hex-Farbe (nicht als Kommentar behandeln)
HEX_COLOR_RE = re.compile(r'#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})\b')

def _unescape(s: str) -> str:
    """
    Erlaubt \n, \t, \x1b usw. wie in sshd_config-ähnlichen Files.
    Beispiel: "\\x1b[32m" -> tatsächliche ESC-Sequenz.
    """
    s = s.strip()
    # Entferne umgebende einfache/doppelte Anführungszeichen (optional)
    if (len(s) >= 2) and ((s[0] == s[-1]) and s[0] in ("'", '"')):
        s = s[1:-1]
    try:
        return bytes(s, "utf-8").decode("unicode_escape")
    except Exception:
        return s  # Fallback: roh zurück

# config_loader.py
def load_config(path: str = "chatti.conf") -> dict[str, str]:
    cfg: dict[str, str] = {}
    try:
        with open(path, encoding="utf-8") as f:
            for raw in f:
                line = raw.strip()
                if not line or line.startswith("#") or line.startswith(";"):
                    continue
                if "=" not in line:
                    continue

                key, val = line.split("=", 1)
                key = key.strip().lower().replace("-", "_")

                # <<< NEU: inline comments am Ende der Zeile entfernen
                val = strip_inline_comment(val.strip())
                val = _unescape(val.strip())
                cfg[key] = val
    except FileNotFoundError:
        pass

    return cfg

def strip_inline_comment(s: str) -> str:
    """
    Schneidet ; oder # als Kommentar ab – aber:
      - NICHT innerhalb von '...' oder "..."
      - NICHT wenn ein # direkt einen Hex-Farbcode einleitet (z.B. #FFA500)

    Beispiel:
      'search_border = #FFA500  # orange'  -> '#FFA500'
      'name = "abc#def"'                   -> '"abc#def"'
      'val = rgb(1,2,3);  # note'          -> 'rgb(1,2,3)'
    """
    in_quote = None
    i = 0
    while i < len(s):
        ch = s[i]
        if ch in ("'", '"'):
            if in_quote == ch:
                in_quote = None
            elif in_quote is None:
                in_quote = ch
        elif ch in ("#", ";") and in_quote is None:
            if ch == "#":
                # Wenn hier eine Hex-Farbe startet, ist das KEIN Kommentar
                if HEX_COLOR_RE.match(s[i:]):
                    i += 1
                    continue
            return s[:i].rstrip()
        i += 1
    return s.rstrip()

def as_bool(cfg: dict, key: str, default: bool=False) -> bool:
    v = cfg.get(key, default)
    if isinstance(v, bool):
        return v
    s = str(v).strip().lower()
    return s in ("1", "true", "yes", "on")


# -----------------------------------------------
# Farben: Namen -> ANSI (für Terminal-Textfarben)
# -----------------------------------------------

COLOR_NAME_TO_ANSI: dict[str, str] = {
    "black": "\x1b[30m",
    "red": "\x1b[31m",
    "green": "\x1b[32m",
    "yellow": "\x1b[33m",
    "blue": "\x1b[34m",
    "magenta": "\x1b[35m",
    "cyan": "\x1b[36m",
    "white": "\x1b[37m",
    "bright_black": "\x1b[90m",
    "bright_red": "\x1b[91m",
    "bright_green": "\x1b[92m",
    "bright_yellow": "\x1b[93m",
    "bright_blue": "\x1b[94m",
    "bright_magenta": "\x1b[95m",
    "bright_cyan": "\x1b[96m",
    "bright_white": "\x1b[97m",
    "bold": "\x1b[1m",
    "reset": "\x1b[0m",
}

def normalize_color(value: str | None) -> str | None:
    """
    Nimmt entweder einen Farbnamen (z.B. 'yellow') oder bereits eine ANSI-Sequenz
    (z.B. '\\x1b[33m') entgegen und liefert eine ANSI-Sequenz zurück.
    - None oder unbekannte Werte -> None (Callsite kann dann Default nehmen)
    - Hex-Farben ('#FFA500') werden nicht zu ANSI gemappt (bewusst),
      weil sie typischerweise für CSS (Rahmenfarben) gedacht sind.
    """
    if not value:
        return None
    v = value.strip()
    # Bereits ANSI?
    if v.startswith("\x1b["):
        return v
    # Bekannter Name?
    ansi = COLOR_NAME_TO_ANSI.get(v.lower())
    if ansi:
        return ansi
    # Hex -> nicht anfassen (für CSS gedacht)
    if HEX_COLOR_RE.match(v):
        return None
    # Unbekannt -> None
    return None

def get_color(cfg: dict[str, str], key: str, default: str | None = None) -> str | None:
    """
    Hol' einen Farbwert aus der Config und normalisiere ihn zu ANSI (oder None).
    Wenn nicht vorhanden/erkennbar, gib 'default' zurück.
    """
    raw = cfg.get(key)
    norm = normalize_color(raw)
    return norm if norm is not None else default
